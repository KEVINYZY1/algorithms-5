### 赋值运算符

赋值运算符前面讲了C++中几个有趣的问题：

(1) 一个空类或者空类对象的大小？

由于对象在内存中必须占有一定的空间，因此，即使类是空的，这个类的对象也要占用一定的空间。VS和G++中空类的大小都是1。

(2) 在空类中添加构造函数和析构函数，这个类对象的大小？

这里要明确的是：一个类对象在内存中包含哪些成员？在C++中，类对象中只有非静态的数据成员和虚表指针(如果有的话)。也就是说，虽然函数好像包含在对象中，但是，经过编译之后，类的函数就会编译成像C语言一样的全局函数，只是通过特定的对象进行调用。因此，在空类中添加函数并不会引起类对象大小的变化。

(3) 复制构造函数

书中给了下面这样的代码：
``` C++
class A {
private:
	int value;

public:
	A(int n) { value = n; }
	A(A other) { value = other.value; }

	void Print() { std::cout << value << std::endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
	A a = 10;
	A b = a;
	b.Print();

	return 0;
}
```
我们必须知道的是，复制构造函数有三个场景下会被调用：
* 函数传递对象时；
* 函数返回对象时；
* 将一个对象赋给一个新的对象。
类A定义了复制构造函数，但是，其中的参数采用的是值传递。如果它是复制构造函数，主函数在调用A b = a;时，就会调用这个复制构造函数，但是，由于它采用值传递，那么还会调用复制构造函数，就产生了无限循环。因此，它是个错误的复制构造函数。编译这个程序时，G++会产生以下错误：
```
错误： 无效的构造函数：您要的可能是‘A (const A&)’
```
因此，复制构造函数的参数必须是const的引用，原因如下：
* 参数是const，可以从两方面来考虑，一方面，语义上，既然是复制构造函数，它不应该修改参数的值，因此，它应该是const；另一方面，如果不是const的话，上述代码中的A a = 10;就不能通过编译，因为这行代码会以这样的方式调用(这里有点问题，待查阅)。
* 参数是引用，防止产生无限循环，而且减少复制次数。

