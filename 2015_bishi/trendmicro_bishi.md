## 趋势科技(笔试[武汉]2014/9/23)

http://www.itmian4.com/thread-6343-1-1.html

1 下面哪些函数可以把字符串t的内容拷贝到s(假设s和t都不等于NULL，并且s的空间也足够)

A

``` C++
void f(char *s, char *t)
{
    do {
        *s++ = *t++;
    } while(*t != '\0');
}
```

B

``` C++
void f(char *s, char *t)
{
    while(*t) {
        *s++ = *t++;
    }
    *s = '\0';
}
```

C

``` C++
void f(char *s, char *t)
{
    do {
        *s = *t;
        s++;
    } while(*t++);
}
```
D

``` C++
void f(char *s, char *t)
{
    unsigned i;
    for(i = 0; i < strlen(t); i++) {
        s[i] = t[i];
    }
}
```

E

``` C++
void f(char *s, char *t)
{
    unsigned i;
    for(i = 0; i < sizeof(t); i++) {
        s[i] = t[i];
    }
}
```

主要考虑是否将字符串末尾的'\0'也放到s的末尾。

A选项：当t遍历到'\0'时，退出循环，因此，并未拷贝'\0'。

B选项：当t遍历到'\0'时，退出循环，然后手动添加'\0'，因此，B是可以的。

C选项：当t遍历到最后一个字符时，会再进行一次循环，因此，会拷贝'\0'，C也是可以的。

D选项：strlen()的结果不包括后面的'\0'，因此，不会拷贝'\0'。

E选项：参数是指针，sizeof(ptr)的结果是4。

因此，选BC。

备注：关于C语言中的'\0'和0。

C语言中，不可打印字符通常用转义字符，例如，换行符\n，水平制表符\t等。C风格字符串的结束标志是'\0'，它的ASCII码值是0。

用char ch = 0;时，ch的ASCII码值就是0。用char ch = '0'时，ch的ASCII码值就是'0'的ASCII值，即48，也即char ch = 48。

因此，上面的*t != '\0'，即*t != 0。

2 对于下列的程序片段，哪些表达式的结果是6？

``` C++
int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
int i = 1, j = 2;
```

A **(arr + 3 *i + j)

B *(*(arr + i) + j)

C *(arr[i] + j)

D *(arr + 3 * i + j)

表达式的结果是6，说明表达式应该访问arr[i][j]，因此，就是找到可以变成arr[i][j]的等价表达式。

首先要理解的一个问题是：如何计算ptr + i，其中ptr为指针。计算ptr + i要根据ptr的类型，也就是指针移动i * sizeof(*ptr)个字节。

A选项：arr的类型是int *[3]，arr + x就移动x * 3 * sizeof(int)，因此，**(arr + 3 * i + j) = **(arr + 5)，移动5 * 3个int，已经超出二维数组的了。A错误。

B选项：同上，*(arr + i)移动1 * 3 = 3个int，结果就是二维数组的第二个一维数组，然后再加j即移动2个int，就到了第三个元素，取值就是3。B正确。

C选项：arr[i] = *(arr + i)。B正确。

D选项：D同A类似，arr + 3 * i + j已经超出二维数组的空间了，而且D的结果是个一维数组。

3 在下面的HTTP方法中，哪个操作不是幂等的？

A GET

B POST

C PUT

D DELETE

幂等的定义为：一次或者多次请求某一个资源应该有同样的副作用。也就是说，服务器不会由于多次操作而造成不可接受的结果。例如，如果用户想要修改服务器的某个资源，发送请求后，处理成功，但是，服务器的响应消息丢失了。于是，客户端再次发送修改资源的请求，服务器并不知道资源已经修改了，可能会再次修改资源。这样就使得修改操作进行了两次。这就不是幂等的。

GET：查，获取资源信息，多次跟一次的结果是一样的，因此，是幂等的。

POST：改，修改一个资源，多次跟一次的修改造成的结果是一样的，因此，是幂等的。

PUT：增，对一个资源进行增加操作，服务器并不知道这次的增加操作跟以前的增加操作是否是同一个操作，因此，针对多次增加操作，服务器会多次进行增加，因此，不是幂等的。

DELETE：删，删除某个资源，如果服务器已经删除了，那么，之后要删除这个资源时，就没有任何操作，因此，是幂等的。

4 下面的代码可能有错误的是：

大致代码如下：

``` C++
template < unsigned int size >
class CTestObj {
public:
	CTestObj(int &arr[size])
	{
	}
};

int main(int argc, char *argv[])
{
    try {
        int arr[] = {1, 2, 3, 4, 500};
        CTestObj<_countof(arr)> *pobj = new CTestObj<_countof(arr)>(arr);
        pobj->Test();
        delete pobj;
    }
    catch(std::exception &) {
        cout << "exception" << endl;
        delete pobj;
    }
}
```

代码解读：

第1行，模板参数为unsigned int size，不是一般的类型，在实例化时形参必须是常量，所以，13行创建对象时参数必须是常量，而不能是_countof的返回值。第4行，构造函数的参数是引用数组，这里不能理解为数组的引用，因此不能理解为int (&arr)[size]，要理解为(int &)arr[size]，所以，13行创建对象时参数不是引用数组，编译不通过。第12行，定义了一个5个元素的int型数组。第13行，用new操作符创建对象指针。第14行，调用CTestObj的Test，这个函数会抛出异常，这里略去。第15行，调用delete删除对象。第19行，在异常处理中调用delete删除对象，但是，当控制流程在异常处理中时，已经超出了pobj的作用域，也会编译失败。

通过上面的分析，会编译失败的有：13行和19行。