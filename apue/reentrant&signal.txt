可重入性与线程安全
1 概念
可重入性是指多个线程调用时，不用担心数据丢失和程序数据损坏。
线程安全是指一个函数可以被多个线程安全地调用。

2 不同点
线程安全只需要考虑多个线程调用某个函数时，结果跟单线程调用该函数的结果一样。而可重入需要考虑各方面的因素，主要就是信号带来的影响。当一个函数在执行时被信号打断了，就会去执行信号处理函数，函数当然不知道信号处理函数中会调用什么代码，那么，信号处理函数的代码的执行可能会对函数本身的执行造成影响。
一个程序是线程安全的，但是它不一样是可重入的。
一个程序是可重入的，那么，它一定是线程安全的。

3 举例说明
3.1 对于errno，由于每个线程中都有一个副本，因此，如果一个函数调用了一个修改errno的函数，那么该函数是线程安全的，因为，多个线程同时调用这个函数并不会对errno的使用产生错误。然而，却不是可重入的。
void func()
{
    func1();
    if(errno == EFAULT) {
        /* some error handling */
    }
}
func1()的调用会修改errno，如果在func1()和if语句之间收到了信号，在信号处理函数中会调用另外一个修改errno的函数，那么信号处理函数返回后，if语句检查的就是信号处理函数中的那个函数的errno，明显发生了错误。

3.2 如果一个函数使用了静态变量，那么，它可能不是线程安全的，当然，也可能不是可重入的。
int func()
{
    static int i = 1;
    ++i;
    return i;
}
如上的代码，该函数使用了静态变量i，然后对i自增，返回i。如果两个线程同时调用两个函数，就会发生错误。对于这种情况可以使用锁来保证i的互斥访问，或者使用局部变量。

4 小结
线程安全考虑的只是代码多次交叉执行时是否会发生错误或者不一致的情况，如果有下列情况就不是线程安全的：
（1）使用了静态变量。如果代码使用了静态变量，多次执行时，不同的线程可能会看到不一致的结果。
（2）结果存放在静态存储区中。同（1）一样，将结果存放在静态存储区中，多个线程可能会先后修改该存储区，导致并不是自己想要的结果。
因此，对于线程安全主要考虑的是静态变量，通过对静态变量进行加锁或者使用局部变量可以得到函数的线程安全版本。

可重入性在考虑线程安全的基础上还考虑了信号的影响，如果有下列情况就不是可重入的：
信号处理函数中调用了不可重入函数。如果信号处理函数调用了不可重入函数，那么在信号发生后，信号处理函数的结果是未知的。
这里没有列出静态变量的情形，因为不是线程安全的，肯定是不可重入的。
需要一提的是，malloc、free和I/O标准库是不可重入的。
